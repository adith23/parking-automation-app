<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Define Parking Slots</title>

    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #f0f0f0;
            margin: 0;
            padding: 10px;
        }

        #container {
            position: relative;
            width: 100%;
            max-width: 800px;
            background: #000;
            overflow: hidden;
        }

        #video-stream {
            display: block;
            width: 100%;
            height: auto;
            background: #000;
        }

        #drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            width: 100%;
            height: 100%;
            pointer-events: auto;
        }

        #controls {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        button {
            font-size: 16px;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
            border: 1px solid #ccc;
        }

        #finish-btn {
            background-color: #28a745;
            color: white;
        }

        #delete-btn {
            background-color: #dc3545;
            color: white;
        }

        .status {
            margin-top: 10px;
            padding: 10px 20px;
            background: #333;
            color: #fff;
            border-radius: 5px;
            font-size: 14px;
            text-align: center;
        }

        .status.connected {
            background: #4CAF50;
        }

        .status.error {
            background: #f44336;
        }

        .status.connecting {
            background: #ff9800;
        }
    </style>
</head>

<body>
    <h4>Define Slots for Lot: {{ parking_lot_id }}</h4>
    <div id="status" class="status connecting">Connecting to video stream...</div>

    <div id="container">
        <video id="video-stream" autoplay playsinline muted></video>
        <canvas id="drawing-canvas"></canvas>
    </div>

    <div id="controls">
        <button id="save-slot-btn">Save Current Slot</button>
        <button id="reset-btn">Reset Points</button>
        <button id="delete-btn">Delete Last Slot</button>
        <button id="finish-btn">Finish & Save All</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/webrtc-adapter@8.1.2/out/adapter.min.js"></script>
    <script>
        const video = document.getElementById("video-stream");
        const canvas = document.getElementById("drawing-canvas");
        const ctx = canvas.getContext("2d");
        const statusElement = document.getElementById("status");
        const parkingLotId = "{{ parking_lot_id }}";

        let currentPoints = [];
        let savedPolygons = [];
        let peerConnection = null;

        // Correctly size canvas relative to parent container
        function resizeCanvas() {
            const container = document.getElementById("container");
            const videoWidth = video.videoWidth || container.clientWidth;
            const videoHeight = video.videoHeight || (container.clientWidth * 9) / 16;
            const aspectRatio = videoWidth / videoHeight;

            // Maintain the video aspect ratio inside container
            const displayWidth = container.clientWidth;
            const displayHeight = displayWidth / aspectRatio;

            video.style.height = `${displayHeight}px`;
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            draw();
        }

        // Wait for video dimensions before sizing
        video.addEventListener("loadedmetadata", resizeCanvas);
        window.addEventListener("resize", resizeCanvas);

        // Compute coordinates relative to the canvas itself, not the whole page
        canvas.addEventListener("click", (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = (event.offsetX / rect.width) * canvas.width;
            const y = (event.offsetY / rect.height) * canvas.height;
            currentPoints.push([Math.round(x), Math.round(y)]);
            draw();
        });

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.lineWidth = 2;

            // Saved polygons
            savedPolygons.forEach((poly) => {
                ctx.beginPath();
                ctx.moveTo(poly[0][0], poly[0][1]);
                poly.forEach((p) => ctx.lineTo(p[0], p[1]));
                ctx.closePath();
                ctx.fillStyle = "rgba(0, 255, 0, 0.4)"; 
                ctx.fill();
                ctx.strokeStyle = "#00ff00"; 
                ctx.stroke();
            });

            // Current polygon
            if (currentPoints.length > 0) {
                ctx.strokeStyle = "#ff0000";
                ctx.fillStyle = "#ff0000";
                ctx.beginPath();
                ctx.moveTo(currentPoints[0][0], currentPoints[0][1]);
                currentPoints.forEach((p) => ctx.lineTo(p[0], p[1]));
                ctx.stroke();

                currentPoints.forEach((p) => {
                    ctx.beginPath();
                    ctx.arc(p[0], p[1], 4, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }

        // Control buttons
        document.getElementById("save-slot-btn").addEventListener("click", () => {
            if (currentPoints.length > 2) {
                savedPolygons.push([...currentPoints]);
                currentPoints = [];
                draw();
            } else {
                alert("Need at least 3 points to define a slot.");
            }
        });

        document.getElementById("reset-btn").addEventListener("click", () => {
            currentPoints = [];
            draw();
        });

        document.getElementById("delete-btn").addEventListener("click", () => {
            if (savedPolygons.length > 0) {
                savedPolygons.pop();
                draw();
            }
        });

        document.getElementById("finish-btn").addEventListener("click", async () => {
            if (savedPolygons.length === 0) {
                alert("No slots have been saved.");
                return;
            }

            const scaleX = video.videoWidth / canvas.width;
            const scaleY = video.videoHeight / canvas.height;

            const payload = {
                slots: savedPolygons.map((poly) => ({
                    coordinates: poly.map((p) => [
                        Math.round(p[0] * scaleX),
                        Math.round(p[1] * scaleY),
                    ]),
                })),
            };

            try {
                const backendUrl = window.location.origin;
                const response = await fetch(
                    `${backendUrl}/api/v1/owner/slot-definitions/${parkingLotId}/slots`,
                    {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload),
                    }
                );
                const result = await response.json();
                alert(response.ok ? result.message : `Error: ${result.detail}`);
            } catch (err) {
                console.error(err);
                alert("An error occurred while saving slots.");
            }
        });

        function updateStatus(msg, cls) {
            statusElement.textContent = msg;
            statusElement.className = "status " + cls;
        }

        // --- WebRTC setup (unchanged) ---
        async function setupWebRTC() {
            try {
                updateStatus("Connecting...", "connecting");
                peerConnection = new RTCPeerConnection({
                    iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }],
                });

                peerConnection.ontrack = (event) => {
                    if (event.track.kind === "video") {
                        video.srcObject = event.streams[0];
                        video.play().catch(() => { });
                        updateStatus("Connected", "connected");
                    }
                };

                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: false,
                    offerToReceiveVideo: true,
                });
                await peerConnection.setLocalDescription(offer);

                const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
                const wsUrl = `${protocol}//${window.location.host}/api/v1/owner/slot-definitions/ws/${parkingLotId}/define-slots`;

                const ws = new WebSocket(wsUrl);
                ws.onopen = () => {
                    ws.send(JSON.stringify({
                        type: "offer",
                        sdp: peerConnection.localDescription.sdp,
                    }));
                };

                ws.onmessage = async (event) => {
                    const data = JSON.parse(event.data);
                    if (data.type === "answer") {
                        await peerConnection.setRemoteDescription(
                            new RTCSessionDescription({
                                type: "answer",
                                sdp: data.sdp,
                            })
                        );
                        updateStatus("Connected", "connected");
                    }
                };

                ws.onerror = () => updateStatus("WebSocket Error", "error");
                ws.onclose = () => updateStatus("Disconnected", "error");
            } catch (e) {
                console.error(e);
                updateStatus("WebRTC Setup Failed", "error");
            }
        }

        setupWebRTC();
    </script>
</body>

</html>